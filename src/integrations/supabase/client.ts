
// This file is automatically generated. Do not edit it directly.
import { createClient, Session, User } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://wlawjupusugrhojbywyq.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndsYXdqdXB1c3VncmhvamJ5d3lxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDYwMTIxOTYsImV4cCI6MjA2MTU4ODE5Nn0.-TMflVxBkU4MTTxRWd0jrSiNBCLhxnl8R4EqsrWrSlg";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

export const checkSupabaseConnection = async (retries = 3, delay = 1000): Promise<{ connected: boolean, latency?: number, error?: string }> => {
  if (typeof navigator !== 'undefined' && !navigator.onLine) {
    return { connected: false, error: 'Offline' };
  }
  for (let i = 0; i < retries; i++) {
    try {
      const startTime = Date.now();
      // Attempt a lightweight query, e.g., fetching the session.
      await supabase.auth.getSession();
      const endTime = Date.now();
      return { connected: true, latency: endTime - startTime };
    } catch (error: any) {
      if (i < retries - 1) {
        await new Promise(resolve => setTimeout(resolve, delay));
      } else {
        console.error('Supabase connection check failed:', error);
        return { connected: false, error: error.message };
      }
    }
  }
  // This line should ideally not be reached if the loop logic is correct
  return { connected: false, error: 'Max retries reached without success or explicit failure.' };
};

export const isOffline = (): boolean => {
  return typeof navigator !== 'undefined' && !navigator.onLine;
};

export const requireAuth = async <T>(callback: () => Promise<T>): Promise<T | undefined> => {
  const { data: { session }, error: sessionError } = await supabase.auth.getSession();

  if (sessionError) {
    console.error('Error fetching session for requireAuth:', sessionError);
    // Potentially throw or handle as unauthenticated
    return undefined;
  }

  if (!session) {
    console.warn('Authentication required, but no session found.');
    // In a real app, this might trigger a redirect to a login page
    // or throw an error that the UI can catch to show a login prompt.
    // Returning undefined allows the caller to decide how to handle it.
    return undefined;
  }

  // If a session exists, proceed with the callback
  try {
    return await callback();
  } catch (error) {
    console.error('Error executing authenticated callback:', error);
    throw error; // Re-throw the error to be handled by the caller
  }
};

export const cacheDataForOffline = async (key: string, data: any): Promise<void> => {
  console.log(`Attempting to cache data for offline use with key: ${key}`, data);
  try {
    if (typeof localStorage !== 'undefined') {
      localStorage.setItem(key, JSON.stringify(data));
      console.log(`Data cached successfully for key: ${key}`);
    } else {
      console.warn('localStorage is not available. Cannot cache data for offline use.');
    }
  } catch (error) {
    console.error('Failed to cache data for offline use:', error);
    // Optionally, re-throw or handle as needed
  }
};

export const cancelClassBooking = async (bookingId: string | number, userId: string): Promise<any> => {
  console.log(`Attempting to cancel booking ${bookingId} for user ${userId}`);
  // Assuming 'bookings' table and 'user_id' column. Adjust if schema is different.
  // Also, ensure RLS policies on 'bookings' table allow this operation for the authenticated user.
  const { data, error } = await supabase
    .from('bookings')
    .delete()
    .match({ id: bookingId, user_id: userId }); // Ensure 'user_id' is the correct column name

  if (error) {
    console.error('Error cancelling class booking in Supabase:', error);
    throw error; // Re-throw the error to be handled by the caller
  }

  console.log('Class booking cancelled successfully in Supabase:', data);
  return data;
};

